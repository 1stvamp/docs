extends inc/layout

block vars
  - var title='Authoring Charms'
  - var page='authors-subordinate-services'

block content
  article.
      <section id ="subordinate-services">

      <h1>Subordinate services</h1>
      <p>Services are composed of one or more service units. A service unit runs the service's software and is the smallest entity managed by juju. Service units are typically run in an isolated container on a machine with no knowledge or access to other services deployed onto the same machine. Subordinate services allows for units of different services to be deployed into the same container and to have knowledge of each other.</p>

      <h2>Motivations</h2>
      <p>Services such as logging, monitoring, backups and some types of storage often require some access to the runtime of the service they wish to operate on. Under the current modeling of services it is only possible to relate services to other services with an explicit interface pairing.  Requiring a specified relation implies that every charm author need be aware of any and all services a deployment might wish to depend on, even if the other service can operate without any explicit cooperation.  For example a logging service may only require access to the container level logging directory to function.</p>
      <p>The following changes are designed to address these issues and allow a class of charm that can execute in the context of an existing container while still taking advantage of the existing relationship machinery.</p>
      <h2>Terms</h2>
      <dl class="docutils">
      <dt>Principal service</dt>
      <dd>A traditional service or charm  in whose container subordinate services will execute.</dd>
      <dt>Subordinate service/charm</dt>
      <dd>A service designed for and deployed to the running container of another service unit.</dd>
      <dt>Container relation</dt>
      <dd>A <cite>scope: container</cite> relationship. While modeled identically to traditional, <cite>scope: global</cite>, relationships, juju only implements the relationship between the units belonging to the same container.</dd>
      </dl>

      <h2>Relations</h2>
      <p>When a traditional relation is added between two services, all the service units for the first service will receive relation events about all service units for the second service. Subordinate services have a very tight relationship with their principal service, so it makes sense to be able to restrict that communication in some cases so that they only receive events about each other. That's precisely what happens when a relation is tagged as being a scoped to the container. See <a class="reference external" href="charm.html"><em>scoped relations</em></a>.</p>
      <p>Container relations exist because they simplify responsibilities for the subordinate service charm author who would otherwise always have to filter units of their relation before finding the unit they can operate on.</p>
      <p>If a subordinate service needs to communicate with all units of the principal service, it can still establish a traditional (non-container) relationship to it.</p>
      <p>In order to deploy a subordinate service a <cite>scope: container</cite> relationship is required. Even when the principal services' charm author doesn't provide an explicit relationship for the subordinate to join, using an <a class="reference external" href="implicit-relations.html"><em>implicit relation</em></a> with <cite>scope: container</cite> will satisfy this constraint.</p>
      
      <h2>Addressability</h2>
      <p>No special changes are made for the purpose of naming or addressing subordinate units. If a subordinate logging service is deployed with a single unit of wordpress we would expect the logging unit to be addressable as logging/0, if this service were then related to a mysql service with a single unit we'd expect logging/1 to be deployed in its container. Subordinate units inherit the public/private address of the principal service. The container of the principal defines the network setup.</p>
      
      <h2>Declaring subordinate charms</h2>
      <p>When a charm author wishes to indicate their charm should operate as a subordinate service only a small change to the subordinate charm's metadata is required. Adding <cite>subordinate: true</cite> as a top-level attribute indicates the charm is intended only to deploy in an existing container. Subordinate charms should then declare a required interface with <cite>scope: container</cite> in the relation definition of the charms metadata. Subordinate services may still declare traditional relations to any service. The deployment is delayed until a container relation is added.</p>
      <p><cite>subordinate: false</cite> charms (the default) may still declare relations as <cite>scope: container</cite>. Principal charms providing or requiring <cite>scope: container</cite> relations will only be able to form relations with <cite>subordinate: true</cite> charms.</p>
      <p>The example below shows adding a container relation to a charm.</p>
      <pre>requires:
          logging-directory:
             interface: logging
             scope: container</pre>
      
      
      <h2>Status of subordinates</h2>
      <p>The status output contains details about subordinate units under the status of the principal service unit that it is sharing the container with. The subordinate unit's output matches the formatting of existing unit entries but omits <cite>machine</cite>, <cite>public-address</cite> and <cite>subordinates</cite> (which are all the same as the principal unit).</p>
      <p>The subordinate service is listed in the top level <cite>services</cite> dictionary in an abbreviated form. The <cite>subordinate-to: []</cite> list is
      added to the service which contains the names of all services this service is subordinate to.</p>
      <pre>services:
        rsyslog:
          charm: local:series/rsyslog-1
          subordinate-to: [wordpress]
          relations:
           rsyslog-directory: wordpress
        wordpress:
           machine: 0
           public-address: wordpress-0.example.com
           charm: local:series/wordpress-3
           relations: {rsyslog-directory: rsyslog}
           units:
             wordpress/0:
               relations:
                 rsyslog: {state: up}
               state: started
               subordinates:
                   rsyslog/0:
                     relations:
                       rsyslog-directory: {state: up}</pre>
      
      <h2>Usage</h2>
      <p>Assume the following deployment:</p>
      <pre>juju deploy mysql
      juju deploy wordpress
      juju add-relation mysql wordpress</pre>
      
      <p>Now we'll create a subordinate rsyslog service:</p>
      <pre>juju deploy rsyslog
      juju add-relation rsyslog mysql
      juju add-relation rsyslog wordpress</pre>
      
      <p>This will create a rsyslog service unit inside each of the containers holding the mysql and wordpress units. The rsyslog service has a standard client-server relation to both wordpress and mysql but these new relationships are implemented only between the principal unit and the subordinate unit . A subordinate unit may still have standard relations established with any unit in its environment as usual.</p>

      <h2>Restrictions</h2>
      <p>The initial release of subordinates doesn't include support for removing subordinate units from their principal service apart from removing the principal service itself. This limitation stems from the current policy around service shutdown and the invocation of stop hooks.</p>
      
            </section>
