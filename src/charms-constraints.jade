extends inc/layout

block vars
  - var title='Using Constraints'
  - var page='charms-constraints'

block content
  article.
    <section id ="charms-constraints">
      <h1>Machine Constraints</h1>
      <p>Machine constraints allow you to pick the hardware to which your services will be deployed.</p>
      <p>Constraints can be set for environments and services, with lookups for each key falling back from more specific to more general settings, and with default values set by juju when otherwise unspecified. Changes to constraints do not affect any unit that has already been assigned to a machine.</p>
      <p>Constraints will be controlled with a new command, <span class="pre">juju set-constraints</span>, taking an optional <span class="pre">--service</span> arg, and any number of <span class="pre">key=value</span> pairs. When the service name is specified, the constraints are set on that service; otherwise they are set on the environment.</p>
      <p>Valid choices for the <span class="pre">value</span> are generally dependent on the particular constraint, with two exceptions:</p>

      <ul>
      <li>An empty value always means &quot;use the juju default setting&quot;. This allows you to ignore environment settings at the service level without having to explicitly remember and re-set the juju default values. Note that there is no way to change the juju default values.</li>
      <li>A value of <span class="pre">any</span> explicitly unsets a constraint, and will cause it to be chosen completely arbitrarily.</li>
      </ul>

      <p>We also extend the syntax for <span class="pre">juju deploy</span>, and <span class="pre">juju bootstrap</span>, such that <span class="pre">--constraints</span> expects a single string of space-separated constraints, understood as above; deployment constraints will be set on the service before the first unit is deployed, and bootstrap constraints will be set on the environment and used to provision the initial master machine.</p>
      <p>Please note that there are no changes to the <span class="pre">juju add-unit</span> command; juju is explicitly focused on <strong>service</strong> orchestration, and it is counterproductive to encourage users to consider individual units. This can be worked around by setting new service constraints before adding new units, but is not encouraged.</p>
      <p>The new <span class="pre">juju get-constraints</span> command is used to see the currently applicable constraints. When called without arguments, it outputs the environment constraints as a single yaml-formatted dict; alternatively, it can be called with any number of arguments referencing any mix of services, service units, or machines, and will output a yaml-formatted dict of dicts with the outer dict keyed on the requested entities.</p>

      <h1>Examples</h1>
      
      <p>Launch a new deployment running on an m1.medium (running an i386 image), and defaulting to that for future services:</p>
      <pre><code>juju bootstrap --constraints "instance-type=m1.medium arch=i386"</code></pre>
      
      <p>Deploy MySQL on a machine with at least 32GiB of RAM, and at least 8 ECU of CPU power (architecture will be inherited from the environment, or default to amd64):</p>
      <pre><code>juju deploy --constraints "cpu=8 mem=32G" mysql</code></pre>


      <p>Launch all future &quot;mysql&quot; machines with at least 8GiB of RAM and 4 ECU:</p>
      <pre><code>juju set-constraints --service mysql mem=8G cpu=4</code></pre>

      <p>Output current environment constraints:</p>
      <pre><code>juju get-constraints</code></pre>

      <p>Output constraints for machine 3, service &quot;mysql&quot;, and service unit &quot;wordpress/7&quot;:</p>
      <pre><code>juju get-constraints 3 mysql wordpress/7</code></pre>

      <h1>Provider Constraints</h1>
      <p>The constraints available vary by provider, but should include:</p> 

      <ul>
      <li><span class="pre">cpu</span>: The minimum processing power of the machine, measured in <a class="reference external" href="http://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud#Elastic_compute_units">ECU</a>,defaulting to 1; any real number &gt;= 0 is valid.</li> 
      <li><span class="pre">mem</span>: The minimum memory for the machine, defaulting to 512MB; any real number &gt;= 0, and optionally suffixed with M, G or T is valid.</li>
      <li><span class="pre">arch</span>: The machine's processor architecture, defaulting to &quot;amd64&quot;. Valid values are &quot;i386&quot;, &quot;amd64&quot;, and &quot;arm&quot;.</li>

      </ul>

      <p>The currently available MAAS constraint is:</p>

      <ul>
      <li><span class="pre">maas-name</span>: The MAAS name to which each unit must be deployed. This is philosophically problematic, on the basis that teaching users that it's OK to specify single machines will lead them to pain when they attempt to scale out large deployments; but it's justified on the basis that MAAS itself needs to act as a stepping stone between the &quot;metal&quot; and &quot;cloud&quot; mindsets. <span class="pre">maas-name</span> is unset by default, and should correspond to a name known by the MAAS provider.</li>
      </ul>



      <h1>Working with constraints</h1>
      <p>Here follows a worked example of constraints usage. Assume an Amazon ec2 provider throughout.</p>
      <p>When bootstrapping an environment, you can set the constraints directly:</p>
      <pre><code>juju bootstrap --constraints arch=i386</code></pre>

      <p>The above command did two things:</p>

      <ul>
      <li><p class="first">Set the environment constraints to require machines with an i386 architecture, leaving the other defaults untouched; this is precisely equivalent to:</p>
      
      <pre><code>juju bootstrap --constraints "arch=i386 cpu= mem= "</code></pre>

      <p>...but rather more convenient to type.</p>
      </li>
      <li><p class="first">Started the bootstrap/master machine with the above constraints.</p>
      </li>
      </ul>

      <p>Because the environment constraints were set, subsequent deployments will use the same values:</p>
      <pre><code>juju deploy mysql</code></pre>

      <p>...but other services can be started with their own constraints:</p>
      <pre><code>juju deploy wordpress --constraints mem=1024</code></pre>
 
      <p>Note that the <span class="pre">arch=i386</span> constraint is still inherited from the environment, and that this presents a potential problem:</p>
      <pre><code>juju deploy minecraft --constraints instance-type=cc2.8xlarge</code></pre>

      <p>The above command will still inherit the environment constraints, and will lead to an undeployable service (because cc2.8xlarge cannot run on i386). Running juju debug-log will expose the problem; you can fix it as follows:</p>
      <pre><code>
      juju remove-unit minecraft/0
      juju terminate-machine 1
      juju set-constraints --service minecraft arch=amd64 instance-type=cc2.8xlarge
      juju add-unit minecraft
      </code></pre>
      <p>(You need to remove machine 1's assigned unit before you can terminate it; you need to explicitly terminate the machine to stop the provisioning agent from continuing to attempt to launch it; and you need to set the new service constraints before adding a new unit that will use those constraints.)</p>
      <p>Work on the constraints feature is ongoing, and it will shortly become impossible to specify knowably inconsistent constraints; but it is in general impossible to detect undeployable constraints with absolute certainty (for example, you could deploy with <span class="pre">ec2-zone=a</span> and be running perfectly happily, but see us-east-1a suddenly go down just as you add a unit).</p>
      <h1>Distinctions Between Entities</h1>
      <p>As noted, it is impossible to directly set constraints on machines or service units; however, it is still possible to call <span class="pre">juju get-constraints</span> on those entities. In either case, the constraints are a snapshot of the applicable constraints at entity creation time; so the unit constraints are the combined environment/service constraints from the time at which the unit was created, and the machine constraints are a copy of the unit constraints at that same point in time.</p>
      <p>Storing this data allows us to automatically reprovision unexpectedly dead machines (for example, if you terminate machine 7 via the AWS management console, the provisioning agent will spin up a new instance with the same constraints and redeploy the assigned units); and making the data available via the CLI gives you visibility into the state of your deployment, and allows you to answer questions like &quot;why is this unit running on that machine?&quot;.</p>
      <h1>Legacy Deployments</h1>
      <p>Attempting to use constraints against a deployment that predates their inclusion in juju will not work, because the running legacy code (specifically, the provisioning agent) will not be able to interpret them. Therefore, attempts to specify constraints against legacy deployments will generate errors to inform users of their invalidity; at the agent level they are simply ignored.</p>
      <p>All commands valid before the client upgrade should continue to work as before, as will the EC2 <span class="pre">default-image-id</span> and <span class="pre">default-instance-type</span> environment settings.</p>
